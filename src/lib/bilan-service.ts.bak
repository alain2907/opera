/**
 * Service de calcul du Bilan pour PWA
 * Copié depuis backend/src/bilan/bilan.service.ts
 * Adapté pour utiliser IndexedDB au lieu de TypeORM
 */

import { getDB } from './indexedDB';
import { BILAN_MAPPINGS, BilanMapping } from './bilan-mappings';

export interface LigneBilan {
  section: string;
  ligne_libelle: string;
  code_poste: string;
  niveau: number;
  montant_n: number;
  montant_n_1?: number;
  ordre_affichage: number;
}

export interface ResultatBilan {
  actif: LigneBilan[];
  passif: LigneBilan[];
  total_actif: number;
  total_passif: number;
  equilibre: boolean;
}

export interface DetailCompte {
  numero_compte: string;
  libelle: string;
  solde: number;
}

export interface DetailLigneBilan {
  ligne_libelle: string;
  code_poste: string;
  comptes: DetailCompte[];
  total: number;
  compte_debut: string | null;
  compte_fin: string | null;
  comptes_specifiques: string | null;
}

// Cache pour éviter les calculs redondants et la récursion infinie
let calculCache = new Map<string, number>();

/**
 * Calculer le bilan
 */
export async function calculerBilan(params: {
  exercice_id: number;
  date_cloture: string;
  comparatif?: boolean;
  exercice_id_n_1?: number;
  date_cloture_n_1?: string;
}): Promise<ResultatBilan> {
  const {
    exercice_id,
    date_cloture,
    comparatif,
    exercice_id_n_1,
    date_cloture_n_1,
  } = params;

  // Réinitialiser le cache de calcul pour chaque nouveau calcul
  calculCache.clear();

  // Récupérer le mapping du bilan
  const mappings = BILAN_MAPPINGS.filter(m => m.actif);

  // Calculer la balance pour l'année N
  const balanceN = await calculerBalanceParCompte(
    exercice_id,
    date_cloture,
  );

  // Calculer la balance pour l'année N-1 si comparatif
  let balanceN1: Map<string, number> | undefined;
  if (comparatif && exercice_id_n_1 && date_cloture_n_1) {
    balanceN1 = await calculerBalanceParCompte(
      exercice_id_n_1,
      date_cloture_n_1,
    );
  }

  // Construire les lignes du bilan
  const lignes: LigneBilan[] = [];

  for (const mapping of mappings) {
    const montant_n = calculerMontantLigne(mapping, balanceN, mappings);
    const montant_n_1 = balanceN1
      ? calculerMontantLigne(mapping, balanceN1, mappings)
      : undefined;

    lignes.push({
      section: mapping.section,
      ligne_libelle: mapping.ligne_libelle,
      code_poste: mapping.code_poste || '',
      niveau: mapping.niveau,
      montant_n,
      montant_n_1,
      ordre_affichage: mapping.ordre_affichage,
    });
  }

  // Séparer actif et passif
  const actif = lignes.filter((l) => l.section === 'ACTIF');
  const passif = lignes.filter((l) => l.section === 'PASSIF');

  // Calculer les totaux
  // Pour l'actif, utiliser la ligne 1A (TOTAL après déduction des amortissements)
  const ligne1A = actif.find((l) => l.code_poste === '1A');
  const total_actif = ligne1A ? ligne1A.montant_n : actif
    .filter((l) => l.niveau === 3) // Fallback : sommer les lignes détaillées
    .reduce((sum, l) => sum + l.montant_n, 0);

  // Pour le passif, utiliser la ligne EE (TOTAL GÉNÉRAL PASSIF)
  const ligneEE = passif.find((l) => l.code_poste === 'EE');
  const total_passif = ligneEE ? ligneEE.montant_n : passif
    .filter((l) => l.niveau === 3)
    .reduce((sum, l) => sum + l.montant_n, 0);

  const equilibre = Math.abs(total_actif - total_passif) < 0.01;

  return {
    actif,
    passif,
    total_actif,
    total_passif,
    equilibre,
  };
}

/**
 * Calculer la balance par compte jusqu'à une date de clôture
 */
async function calculerBalanceParCompte(
  exercice_id: number,
  date_cloture: string,
): Promise<Map<string, number>> {
  const db = await getDB();

  // Récupérer toutes les écritures jusqu'à la date de clôture
  const allEcritures = await db.getAll('ecritures');
  const ecritures = allEcritures.filter((e: any) => {
    const ecritureExerciceId = e.exerciceId || e.exercice_id;
    if (ecritureExerciceId !== exercice_id) return false;
    if (e.date > date_cloture) return false;
    return true;
  });

  // Calculer le solde par compte
  const balance = new Map<string, number>();

  for (const ecriture of ecritures) {
    const numeroCompte = ecriture.compteNumero || ecriture.compte_numero;
    if (!numeroCompte) continue;

    const debit = Number(ecriture.debit || 0);
    const credit = Number(ecriture.credit || 0);

    const solde = balance.get(numeroCompte) || 0;
    balance.set(
      numeroCompte,
      solde + debit - credit,
    );
  }

  return balance;
}

/**
 * Calculer le montant d'une ligne du bilan
 */
function calculerMontantLigne(
  mapping: BilanMapping,
  balance: Map<string, number>,
  allMappings: BilanMapping[],
): number {
  // Vérifier le cache pour éviter la récursion infinie
  const cacheKey = mapping.code_poste;
  if (calculCache.has(cacheKey)) {
    return calculCache.get(cacheKey)!;
  }

  // Mettre 0 temporairement dans le cache pour détecter les boucles
  calculCache.set(cacheKey, 0);

  // Cas spécial : Résultat de l'exercice = Produits (classe 7) - Charges (classe 6)
  if (mapping.comptes_specifiques) {
    try {
      const comptesSpec = JSON.parse(mapping.comptes_specifiques);

      if (comptesSpec?.type === 'resultat_exercice') {
        let produits = 0;
        let charges = 0;

        for (const [compte, solde] of balance.entries()) {
          if (compte.startsWith('7')) {
            // Classe 7 : Produits (normalement créditeurs = négatifs en compta)
            produits += Math.abs(solde < 0 ? solde : 0);
          } else if (compte.startsWith('6')) {
            // Classe 6 : Charges (normalement débiteurs = positifs en compta)
            charges += solde > 0 ? solde : 0;
          }
        }

        const resultat = produits - charges;
        console.log(`[RESULTAT DI] Produits(classe 7): ${produits}, Charges(classe 6): ${charges}, Résultat: ${resultat}, Section: ${mapping.section}`);

        // La ligne DI affiche toujours le résultat (bénéfice ou perte)
        // En comptabilité française, le résultat apparaît au PASSIF (bénéfice positif, perte négative)
        console.log(`[RESULTAT DI] Montant final: ${resultat}`);
        calculCache.set(cacheKey, resultat);
        return resultat;
      }

      // Cas spécial : Somme de lignes (pour les totaux/sous-totaux)
      if (comptesSpec?.type === 'somme_lignes' && Array.isArray(comptesSpec?.codes) && allMappings) {
        let somme = 0;
        for (const code of comptesSpec.codes) {
          const ligneMapping = allMappings.find(m => m.code_cerfa === code || m.code_poste === code);
          if (ligneMapping) {
            somme += calculerMontantLigne(ligneMapping, balance, allMappings);
          }
        }
        calculCache.set(cacheKey, somme);
        return somme;
      }

      // Cas spécial : Différence de lignes (pour le net = brut - amortissements)
      if (comptesSpec?.type === 'difference_lignes' && comptesSpec?.base && comptesSpec?.soustrait && allMappings) {
        const baseMapping = allMappings.find(m => m.code_cerfa === comptesSpec.base || m.code_poste === comptesSpec.base);
        const soustraitMapping = allMappings.find(m => m.code_cerfa === comptesSpec.soustrait || m.code_poste === comptesSpec.soustrait);

        const baseValue = baseMapping ? calculerMontantLigne(baseMapping, balance, allMappings) : 0;
        const soustraitValue = soustraitMapping ? calculerMontantLigne(soustraitMapping, balance, allMappings) : 0;

        // Utiliser la valeur absolue de soustraitValue car les comptes d'amortissement sont négatifs
        // Ex: CO = 10000, BK = -300, alors 1A = 10000 - Math.abs(-300) = 9700
        const result = baseValue - Math.abs(soustraitValue);

        console.log(`[DIFFERENCE] ${mapping.code_cerfa}: ${comptesSpec.base}(${baseValue}) - |${comptesSpec.soustrait}|(${Math.abs(soustraitValue)}) = ${result}`);

        calculCache.set(cacheKey, result);
        return result;
      }
    } catch (e) {
      // Ignore parsing errors
    }
  }

  let montant = 0;

  // Parcourir la balance et additionner les comptes correspondants
  for (const [compte, solde] of balance.entries()) {
    let correspondance = false;

    // Vérifier la plage de comptes
    if (mapping.compte_debut && mapping.compte_fin) {
      // Si compte_debut == compte_fin, chercher par préfixe
      if (mapping.compte_debut === mapping.compte_fin) {
        if (compte.startsWith(mapping.compte_debut)) {
          correspondance = true;
        }
      } else {
        // Plage de comptes : vérifier si le compte commence par un préfixe dans la plage
        // Ex: si plage = '43' à '44', accepter tous les comptes commençant par 43 ou 44
        // Utiliser la longueur du préfixe de début pour déterminer la granularité
        const prefixLength = mapping.compte_debut.length;
        const debutNum = parseInt(mapping.compte_debut);
        const finNum = parseInt(mapping.compte_fin);

        for (let prefix = debutNum; prefix <= finNum; prefix++) {
          const prefixStr = prefix.toString().padStart(prefixLength, '0');
          if (compte.startsWith(prefixStr)) {
            correspondance = true;
            break;
          }
        }
      }
    }

    // Vérifier les comptes spécifiques
    if (mapping.comptes_specifiques) {
      try {
        const comptesSpec = JSON.parse(mapping.comptes_specifiques);
        if (Array.isArray(comptesSpec)) {
          // Vérifier si le compte correspond exactement ou commence par un préfixe de la liste
          correspondance = comptesSpec.some(prefix =>
            compte === prefix || compte.startsWith(prefix)
          );
        }
      } catch (e) {
        // Ignore parsing errors
      }
    }

    if (correspondance) {
      // Pour l'actif, on prend les soldes débiteurs (positifs)
      // Pour le passif, on prend les soldes créditeurs (négatifs) en valeur absolue
      if (mapping.section === 'ACTIF') {
        // Les comptes 28 (amortissements), 29, 39, 49 (dépréciations) sont soustractifs
        const estCompteDeductif = compte.startsWith('28') || compte.startsWith('29') ||
                                   compte.startsWith('39') || compte.startsWith('49');

        if (estCompteDeductif) {
          // Pour les comptes déductifs, on prend les soldes créditeurs (négatifs) en valeur négative
          montant += solde < 0 ? solde : 0;
        } else {
          // Pour les comptes normaux d'actif, on prend les soldes débiteurs (positifs)
          montant += solde > 0 ? solde : 0;
        }
      } else if (mapping.section === 'PASSIF') {
        montant += solde < 0 ? Math.abs(solde) : 0;
      }
    }
  }

  // Vérifier s'il faut inverser le signe pour l'affichage (lignes d'amortissement)
  if (mapping.comptes_specifiques) {
    try {
      const comptesSpec = JSON.parse(mapping.comptes_specifiques);
      if (comptesSpec?.inverser_signe) {
        console.log(`[INVERSER SIGNE] ${mapping.code_poste}: ${montant} → ${-montant}`);
        montant = -montant;
      }
    } catch (e) {
      // Ignore parsing errors
    }
  }

  // Mettre en cache et retourner
  calculCache.set(cacheKey, montant);
  return montant;
}
